// ===== MOTOR PINS =====
#define AIN1 3
#define AIN2 4
#define PWMA 9
#define BIN1 6
#define BIN2 7
#define PWMB 10
#define STBY 5

// ===== SENSOR PINS =====
int sensorPins[7] = {A0, A1, A2, A3, A4, A5, A6};
int sensorMin[7];
int sensorMax[7];
int sensorValue[7];

// ===== PID SETTINGS =====
int baseSpeed = 150;        // Increase from 120 - was too slow
float Kp = 0.04;            // Scaled for error range -3000 to +3000
float Ki = 0.0001;          // Small integral to fix steady drift
float Kd = 0.6;             // Smooth derivative

float lastError = 0;
float integral = 0;

// ===== LOST LINE TRACKING =====
int lastKnownError = 0;     // Remember which side we lost the line

void setup() {
  Serial.begin(9600);
  pinMode(AIN1, OUTPUT);
  pinMode(AIN2, OUTPUT);
  pinMode(BIN1, OUTPUT);
  pinMode(BIN2, OUTPUT);
  pinMode(PWMA, OUTPUT);
  pinMode(PWMB, OUTPUT);
  pinMode(STBY, OUTPUT);
  digitalWrite(STBY, HIGH);

  Serial.println("Place robot on track. Calibrating in 5 seconds...");
  delay(5000);
  calibrate();
  Serial.println("Starting line follow...");
}

void loop() {
  int position = readLine();
  bool lineDetected = isLineDetected();

  // ===== LOST LINE RECOVERY =====
  if (!lineDetected) {
    // Slow spin toward last known side instead of stopping
    if (lastKnownError > 0) {
      rotateRight(90);
    } else {
      rotateLeft(90);
    }
    integral = 0; // Reset integral during recovery
    return;
  }

  float error = position;
  lastKnownError = error;

  // ===== PID CALCULATION =====
  integral += error;
  integral = constrain(integral, -3000, 3000); // Prevent integral windup

  float derivative = error - lastError;
  float correction = (Kp * error) + (Ki * integral) + (Kd * derivative);

  lastError = error;

  // ===== DYNAMIC SPEED =====
  // Slow down on curves, speed up on straight
  float errorRatio = abs(error) / 3000.0;       // 0.0 = straight, 1.0 = max curve
  int dynamicSpeed = baseSpeed - (errorRatio * 80); // Reduce max 80 on sharp curves
  dynamicSpeed = constrain(dynamicSpeed, 80, 255);

  // ===== MOTOR MIXING =====
  int leftSpeed  = dynamicSpeed + correction;
  int rightSpeed = dynamicSpeed - correction;

  leftSpeed  = constrain(leftSpeed,  0, 255);
  rightSpeed = constrain(rightSpeed, 0, 255);

  moveForward(leftSpeed, rightSpeed);

  // Debug - comment out after tuning
  Serial.print("Pos: "); Serial.print(position);
  Serial.print(" Err: "); Serial.print(error);
  Serial.print(" Corr: "); Serial.print(correction);
  Serial.print(" L: "); Serial.print(leftSpeed);
  Serial.print(" R: "); Serial.println(rightSpeed);
}

// ===== CHECK IF ANY SENSOR SEES THE LINE =====
bool isLineDetected() {
  for (int i = 0; i < 7; i++) {
    int value = map(sensorValue[i], sensorMin[i], sensorMax[i], 0, 1000);
    value = constrain(value, 0, 1000);
    if (value > 300) return true; // At least one sensor sees the line
  }
  return false;
}

// ===== CALIBRATION =====
void calibrate() {
  for (int i = 0; i < 7; i++) {
    sensorMin[i] = 1023;
    sensorMax[i] = 0;
  }
  rotateLeft(100);
  recordSensors(3000);
  rotateRight(100);
  recordSensors(3000);
  stopMotors();
  Serial.println("Calibration Done");
}

void recordSensors(int duration) {
  unsigned long startTime = millis();
  while (millis() - startTime < duration) {
    for (int i = 0; i < 7; i++) {
      int value = analogRead(sensorPins[i]);
      if (value < sensorMin[i]) sensorMin[i] = value;
      if (value > sensorMax[i]) sensorMax[i] = value;
    }
  }
}

// ===== READ LINE (WEIGHTED AVERAGE) =====
int readLine() {
  long weightedSum = 0;
  long total = 0;
  int weights[7] = {-3000, -2000, -1000, 0, 1000, 2000, 3000};

  for (int i = 0; i < 7; i++) {
    sensorValue[i] = analogRead(sensorPins[i]);
    int value = map(sensorValue[i], sensorMin[i], sensorMax[i], 0, 1000);
    value = constrain(value, 0, 1000);
    weightedSum += (long)value * weights[i];
    total += value;
  }

  if (total == 0) return 0;
  return (int)(weightedSum / total);
}

// ===== MOTOR FUNCTIONS =====
void moveForward(int leftSpeed, int rightSpeed) {
  digitalWrite(AIN1, HIGH);
  digitalWrite(AIN2, LOW);
  digitalWrite(BIN1, HIGH);
  digitalWrite(BIN2, LOW);
  analogWrite(PWMA, leftSpeed);
  analogWrite(PWMB, rightSpeed);
}

void rotateLeft(int speedVal) {
  digitalWrite(AIN1, LOW);
  digitalWrite(AIN2, HIGH);
  digitalWrite(BIN1, HIGH);
  digitalWrite(BIN2, LOW);
  analogWrite(PWMA, speedVal);
  analogWrite(PWMB, speedVal);
}

void rotateRight(int speedVal) {
  digitalWrite(AIN1, HIGH);
  digitalWrite(AIN2, LOW);
  digitalWrite(BIN1, LOW);
  digitalWrite(BIN2, HIGH);
  analogWrite(PWMA, speedVal);
  analogWrite(PWMB, speedVal);
}

void stopMotors() {
  analogWrite(PWMA, 0);
  analogWrite(PWMB, 0);
}
